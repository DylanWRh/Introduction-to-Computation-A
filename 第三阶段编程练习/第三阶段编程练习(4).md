# 第三阶段编程练习(4)

## **001-图案计数**
<details>

<summary>
题目
</summary>

### **题目描述**

一张画布里有n行*m列个格子，其中有的格子里有颜色填充，有的格子是空的没有颜色填充。现在需要你写一个程序来数出画布里边有颜色填充的格子构成了多少个图案，其中图案的定义为：\
如果两个有颜色的格子边相邻或者角相邻（即横、纵两个方向上的位置差都不超过1），则他们属于同一个图案。

### **关于输入**

第一行为两个整数n和m（1<=n, m<=200）。\
之后的n行，每行为一个长度为m的字符串，构成了整个画布。字符串中，#表示颜色，-表示空白。

### **关于输出**

一个整数，表示图案的个数

### **例子输入**

```
19 48
------------------------------------------------
---####-----#-----#----------------------####---
--######----#-----#---------------------######--
-########--#-#---#-#####--#-##-##---#--########-
-###--###--#-#---#-#----#-##-##--#--#--###--###-
-###--###--#--#-#--######-#--#---#-#---###--###-
-########--#--#-#--#------#--#----##---########-
--######---#---#---######-#--#-----#----######--
---####----------------------------#-----####---
----------------------------------#-------------
------------------------------------------------
---###--#--------#------#-----------------------
--#---#-#---------------#-----------------------
-#------#-##--#-##--##-###-#-##-###--###-#--##--
-#------##--#-##-#-#----#--##--#---##---##-#----
-#------#---#-#--#--#---#--#---#---##----#--#---
--#---#-#---#-#--#---#--#--#---#---##---##---#--
---###--#---#-#--#-##---#--#---#---#-###-#-##---
------------------------------------------------
```

### **例子输出**

```
12
```

### **提示信息**

pass

</details>

<details>

<summary>
代码
</summary>

```c++
#include <iostream>
using namespace std;
char paper[210][210]={'\0'};
int used[210][210]={0};
int m=0,n=0,cnt=0;
void dfs(int x,int y){
    if(!(x>=1 && x<=m && y>=1 && y<=n))return;
    if(paper[x][y]=='#' && used[x][y]==0){
        used[x][y]=1;
        dfs(x+1,y);dfs(x-1,y);
        dfs(x,y+1);dfs(x,y-1);
        dfs(x+1,y+1);dfs(x-1,y+1);
        dfs(x+1,y-1);dfs(x-1,y-1);
    }
    return;
}
int main(){
    cin >> m >> n;
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++)cin >> paper[i][j];
    }
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            if(paper[i][j]=='#' && used[i][j]==0){
                dfs(i,j);
                cnt++;
            }
        }
    }
    cout << cnt;
}
```

</details>

## **002-子集合划分**
<details>

<summary>
题目
</summary>

### **题目描述**

将一个没有重复元素的集合A分成若干个非空子集，使得A中每个元素属于且仅属于一个子集，那么这些子集构成的集合称为A的一个划分。现在给定集合的元素个数n，希望知道有多少种不同的划分（假定集合本身属于一种划分），当n=0的时候，也认为有一种划分。\
例如，n=3 时，A={1，2，3}的所有划分如下：\
{ {1} ， {2} ， {3} }\
{ {1 ， 2} ， {3} }\
{ {1 ， 3} ， {2} }\
{ {1} ， {2 ， 3} }\
{ {1 ， 2 ， 3} }\
一共有5种。

### **关于输入**

若干行整数，每行一个整数n，当为-1时结束

### **关于输出**

每行对应的集合划分数（假设可以用long表示）

### **例子输入**

```
0
3
13
-1
```

### **例子输出**

```
1
5
27644437
```

### **提示信息**

pass

</details>

<details>

<summary>
代码
</summary>

```c++
#include <iostream>
using namespace std;
long long C(int a,int b){
    long long result=1;
    for(int i=1;i<=b;i++)result*=(a+1-i);
    for(int i=1;i<=b;i++)result/=i;
    return result;
}
long long get_result(int n){
    if(n==1 || n==0){
        return 1;
    }
    long long result=0;
    for(int i=1;i<=n;i++){
        result+=C(n-1,i-1)*get_result(n-i);
    }
    return result;
}
int main(){
    int n;
    while(cin >> n && n!=-1){
        cout << get_result(n) << endl;
    }
    return 0;
}
```

</details>

## **003-有理数树**
<details>

<summary>
题目
</summary>

### **题目描述**

二叉树指的是一种树形结构，它的每个结点有至多两个子节点。\
现在有一个由有理数组成的无穷二叉树形状如下：
```
         1/1
    ______|_____
    |          |
  1/2         2/1
___|___     ___|___
|    |      |     |
1/3  3/2   2/3  3/1
```
在p/q结点位置的左子节点为p/(p+q)，右子结点为(p+q)/q\
现在已知所有有理数在这个二叉树内都存在，且仅出现一次。我们按照树的层次进行遍历，可以得到一个序列1/1, 1/2, 2/1, 1/3, 3/2, 2/3, 3/1, ...\
请你解决以下问题：对于给定一个有理数，求它在上述序列中的位置

### **关于输入**

首先输入一个整数T，表示测试样例的数目。\
接下来是T行，每行包含两个整数，分别代表有理数的分子与分母

### **关于输出**

对于每一行输入，请输出有理数在序列中的位置，位置从1开始计数,并且结果保证是在int的范围内

### **例子输入**

```
2
1 2
3 2
```

### **例子输出**

```
2
5
```

### **提示信息**

可以使用递归解法

</details>

<details>

<summary>
代码
</summary>

```c++
#include <iostream>
using namespace std;
int main(){
    int n;cin >> n;
    for(int i=0;i<n;i++){
        int p,q;cin >> p >> q;
        int s[1000]={0};
        while(p+q!=2){
            if(p>q){
                p=p-q;
                s[++s[0]]=1;
            }
            else{
                q=q-p;
                s[++s[0]]=0;
            }
        }
        s[++s[0]]=1;
        int result=0;
        for(int i=s[0];i>=1;i--){
            result=2*result+s[i];
        }
        cout << result << endl;
    }  
    return 0;
}
```

</details>

## **004-查看菌落数目**
<details>

<summary>
题目
</summary>

### **题目描述**

菌落的数量对医生来说一直是一个很重要的数据，但是细菌数量太多人工又无法计数，因此你能写个程序帮助医生完成这个任务么？\
有一张n*m的菌落的显微镜照片，每个格子是0(表示当前位置无细菌)或者1(表示当前位置是细菌)，请你输出这张照片中菌落的数量。\
如果一个细菌，其上下左右四个方向有细菌的话，则这些相邻的细菌属于一个菌落。\
例如给定如下照片：\
0 0 1 0\
0 1 0 1\
1 1 0 0\
则给出的照片一共有A,B,C三个菌落，如下：\
0 0 A 0\
0 B 0 C\
B B 0 0

### **关于输入**

输入数据第一行两个整数n,m（1<=n,m<=100）,表示照片的长和宽。\
接下来n行，每行都有m个用空格隔开的整数（0或者1），表示这一照片行的状态（有无细菌）。

### **关于输出**

输出一个整数，表示该张照片中菌落数量

### **例子输入**

```
3 5
0 0 1 0 1
0 1 0 1 1
1 1 0 0 1
```

### **例子输出**

```
3
```

### **提示信息**

pass

</details>

<details>

<summary>
代码
</summary>

```c++
#include <iostream>
using namespace std;
int m,n;int a[100][100];
void dfs(int x,int y){
    if(x+1<m){
        if(a[x+1][y]==1){
            a[x+1][y]=2;
            dfs(x+1,y);
        }
    }
    if(x-1>=0){
        if(a[x-1][y]==1){
            a[x-1][y]=2;
            dfs(x-1,y);
        }
    }
    if(y-1>=0){
        if(a[x][y-1]==1){
            a[x][y-1]=2;
            dfs(x,y-1);
        }
    }
    if(y+1<n){
        if(a[x][y+1]==1){
            a[x][y+1]=2;
            dfs(x,y+1);
        }
    }
}
int main(){
    cin >> m >> n;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++)cin >> a[i][j];
    }
    int cnt=0;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(a[i][j]==1){
                dfs(i,j);
                cnt++;
            }
        }
    }
    cout << cnt;
    return 0;
}
```

</details>

## **005-平衡矩阵**
<details>

<summary>
题目
</summary>

### **题目描述**

现在有一个n阶正整数方阵（n<=7），现在可以对矩阵的任意一行进行左移，具体操作为：每次对于某一行a_i1,a_i2,…,a_in进行一次左移，最左边的元素移动到这一行的末尾，其他元素均向左移动一位，即变为a_i2,a_i3,…,a_in,a_i1。对某一行可以执行任意次的左移。\
现在我们的目标是：通过对矩阵的每一行进行若干次左移，使得矩阵中每列和的最大值最小。

### **关于输入**

输入包含多组数据。\
对于每组数据，第一行为一个正整数n（1<=n<=7），代表矩阵的阶。接下来的n行，每行n个正整数（不超过10000），代表这个矩阵。\
输入数据以一个-1为结尾代表输入结束。

### **关于输出**

对于每组数据，输出一行一个正整数，为最小的最大列和。

### **例子输入**

```
2
4 6
3 7
3
1 2 3
4 5 6
7 8 9
-1
```

### **例子输出**

```
11
15
```

### **提示信息**

pass

</details>

<details>

<summary>
代码
</summary>

```c++
#include <iostream>
using namespace std;
int table[8][8]={0};
int sum[8]={0};
int min_add=0;
int n=0;
int get_min(int row){
    for(int i=1;i<=n;i++){
        if(row!=n)get_min(row+1);
        int tmp=table[row][1];
        int max_add=0;
        for(int j=1;j<n;j++){
            sum[j]=sum[j]-table[row][j]+table[row][j+1];
            max_add=max(max_add,sum[j]);
            table[row][j]=table[row][j+1];
        }
        sum[n]=sum[n]-table[row][n]+tmp;
        max_add=max(max_add,sum[n]);
        table[row][n]=tmp;
        min_add=min(min_add,max_add);
    }
    return min_add;
}
int main(){
    while(cin >> n && n!=-1){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++)cin >> table[i][j];
        }
        for(int i=1;i<=n;i++){
            sum[i]=0;
            for(int j=1;j<=n;j++)sum[i]+=table[j][i];
        }
        int max_add=0;
        for(int i=1;i<=n;i++)max_add=max(max_add,sum[i]);
        min_add=max_add;
        cout << get_min(1) << endl;
    }
}
```

</details>
